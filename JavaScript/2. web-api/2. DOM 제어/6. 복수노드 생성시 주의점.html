<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="fruits"></ul>

  <script>
    // Live DOM : 사전에 미리 랜더링되어 있는 요소 노드
    const $fruits = document.getElementById('fruits'); //$기호 붙인건 태그 끌고올때

    // 과일 이름 텍스트 배열
    const fruitsName = ['Apple', 'Banana', 'Grape', 'Orange'];

    /*
      # 아래 방법의 문제점 :
      - 이미 활성화된 Live DOM에다가 반복해서 가상 DOM을 
        추가하는 행위는 메모리상 높은 비용이 발생함.
      - 활성화된 DOM을 변경조작하는 것은 가능한 하나 
        횟수를 줄여줘야 함.
    */

    /*
    for(let f of fruitsName) {
      // Virtual DOM : 동적으로 만들어진 요소 노드.
      const $li = document.createElement('li');
      $li.textContent = f;
      $fruits.appendChild($li);
    }
    */

    // 가상의 부모 DOM을 생성
    // DocumentFragment
    // 다른 노드를 담는 임시 컨테이너 역할을 하는 가상 DOM 객체
    const $frag = document.createDocumentFragment();//함수임. 이게몬데?

    for(let f of fruitsName) {
      const $li = document.createElement('li'); //요소노드생성
      $li.textContent = f;//텍스트입력
      $frag.appendChild($li);//추가
    }

    $fruits.appendChild($frag);
  </script>
</body>
</html>